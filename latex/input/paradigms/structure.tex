\section{Overview}

\begin{frame}{Overview}
	\begin{itemize}
	\item Lecture 1: Programming Paradigms (PPs): Date + Time
	\item Exercise 1: Date + Time
	\item Lecture 2: Design Patterns (DPs): Date + Time
	\item Exercise 2: Date + Time
	\end{itemize}
	
	\begin{block}{The goal of this course}
		\begin{itemize}
			\item This course does not try to make you a better programmer
			\item But it \stress{does} convey \hl{basic concepts and vocabulary} to make your design decisions more \stress{conciously}
			\item Thinking while coding + reflecting your decisions after coding $\lra$ Experience $\lra$ Great code!
		\end{itemize}
	\end{block}
\end{frame}



\begin{frame}[t]{Programming Paradigms}
	\only<1->{\begin{block}{What \stress{is} a programming paradigm?}
		\begin{itemize}
			\item A \hl{classification of programming languages} based on their features {\small (but most popular languages support multiple paradigms)}
			\item A \hl{programming style} or way programming/thinking
			\item Example: Object Oriented Programming {\small (thinking in terms of objects which contain data and code)}
		\end{itemize}
	\end{block}
	}
	%	
	\only<+->{\begin{block}{Why should I care?}
			\begin{itemize}
				\item Discovering \hl{new ways of thinking} let's you challenge your current believes about how to code 
				\item Learning to choose the \hl{right paradigm for the right problem} or \hl{picking the best of many worlds}
			\end{itemize}
		\end{block}
	}
	%


\end{frame}

\begin{frame}{Programming Paradigms}
	\only<+->{
	\begin{block}{Some problems}
		\begin{itemize}
			\item Too formal definitions can be hard to grasp and sometimes impractical, too loose definitions can be meaningless
			\item Comparing different paradigms requires substantial experience and knowledge in both
		\end{itemize}
	\end{block}
	}
	%
	\begin{block}{My personal approach}
		Rather than asking \enquote{How to define paradigm X?}, ask 
		\begin{itemize}
			\item 
			\item How does it feel? {\small (try to write in exotic languages)}
			\item How would X approach my problems?
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{Lecture 1}{Programming Paradigms}
	% what is a pp?
	\begin{enumerate}
		\setlength{\itemsep}{3ex}
		\item What do we call "good" code/software?
		\item Approaches to writing software
		\item Programming paradigms\vspace{1ex}
		\begin{enumerate}[a]
			\setlength{\itemsep}{1ex}
			\item Object Oriented Programming (OOP)
			\item Functional Programming (FP)
			\item OOP vs FP
			\item Declarative and imperative programming
			\item Other programming paradigms
		\end{enumerate}
	\end{enumerate}
\end{frame}

\section{Good code}

\frame{\tableofcontents[currentsection, currentsubsection]}

\subsection{Objectives}

%\frame{\tableofcontents[currentsection, currentsubsection]}

\begin{frame}{Good code: Objectives}
\begin{block}{Key objectives}{\relax}
	\begin{itemize}
		\item \hhl{Testability}: Make it easy to \hl{ensure} the software is working correctly
		\item \hhl{Maintainability}: Make it easy to \hl{keep} the software working (debugging, reliability, readability, ...)
		\item \hhl{Extendibility}: Make it easy to \hl{add} new functionality
		\item \hhl{Flexibility}: Make it easy to \hl{adapt} to new problems
		\item \hhl{Reusability}: Make it easy to \hl{reuse} code in other projects
	\end{itemize}
\end{block}

\bigskip
{\Large $\lra$ How do I achieve all this?}

\end{frame}

\subsection{Core concepts}

\begin{frame}{Modularity}
	\hhl{Split up code} into parts, e.g. functions, classes, modules, packages, \dots
	
	You have donen well if the parts are 
	\begin{itemize}
		\item as independent as possible
		\item as high inner cohesion as possible <--?
	\end{itemize}
	%high cohesion?
	
	
\end{frame}

\begin{frame}{Isolate what changes}
	
\end{frame}

\begin{frame}{Complex is better than complicated}

\end{frame}




