
\frame{\tableofcontents[currentsection, currentsubsection]}

\subsection{OOP}

\frame{\tableofcontents[currentsection, currentsubsection]}

\begin{frame}{OOP: Idea}
	
	\begin{itemize}
		\item Before OOP: Two \stress{separate} entities: \emph{data} and \emph{functions} (logic)
		\item Inspiration: In the {real world}, {objects} have a \enquote{state} (data) and \enquote{behaviors} (functions)
	\end{itemize}	
	
	\begin{block}{OOP}
	\begin{itemize}		
		\item \stress{Think} in terms of \hl{\defn{objects}} that contain data and offer \hl{\emph{methods}} (functions that operate on objects) $\lra$ Data and functions form a unit
		\item \stress{Focus} on object structure rather than manipulation logic 
		\item \stress{Organize} your code in \hl{\defn{classes}} (blueprints for objects): Every object is \defn{instance} of its class
	\end{itemize}
	\end{block}
	%idea, ..., formal definition, history?
\end{frame}

\begin{frame}[t]{A basic class in python}
	\only<1>{\inputminted[lastline=4]{python}{code/paradigms/oop/class_rectangle.py}}
	\only<2>{\inputminted[lastline=8]{python}{code/paradigms/oop/class_rectangle.py}}
	\only<3>{\inputminted[]{python}{code/paradigms/oop/class_rectangle.py}}
\end{frame}

\begin{frame}[fragile]{Encapsulation and data hiding}
	% data hiding provides security and avoids data corruption
	%Remember: ... separate interface from implementation ... $\lra$ hide internals
	
	\begin{itemize}
		\item \hl{Do not expose object internals that may change in the future} $\lra$ Make certain attributes and methods \hhl{private} (\defn{data hiding})
		\item Rephrased: Separate \hhl{interface} (won't be touched because it's used by others) from \hhl{implementation} (might change) 
		\item In some languages this is \enquote{enforced} (e.g. using the \verb|private| keyword), in others it is denoted by naming conventions (e.g. leading underscore)
	\end{itemize}
\end{frame}

\begin{frame}[t]{Subclasses and Inheritance}
	\only<1->{\hhl{\defn{Subclasses}} are specializations of a class
	\begin{itemize}
		\item inherit attributes/methods of their superclass
		\item can introduce new attributes/methods
		\item can override methods of superclass
	\end{itemize}
	}	
	\only<2>{\inputminted[fontsize=\footnotesize, lastline=6]{python}{code/paradigms/oop/class_inheritance.py}}
	\only<3>{\inputminted[fontsize=\footnotesize]{python}{code/paradigms/oop/class_inheritance.py}}
\end{frame}

\begin{frame}[t]{Abstract methods}
	\begin{columns}[t]
	\column{0.5\textwidth}	
	\begin{itemize}
		\item An \hhl{\defn{abstract method}} is a method that has to be implemented by a subclass
		\item An \hhl{\defn{abstract class}} (\hhl{\defn{abstract type}}) is a class that cannot be instantiated directly but it might have \hhl{\defn{concrete subclasses}} that can
		\item Use abstract classes to \hl{enforce interfaces} for the concrete classes
	\end{itemize}
	\column{0.5\textwidth}
	\only<2>{\inputminted[fontsize=\small, lastline=11]{python}{code/paradigms/oop/class_abstract.py}}
	\only<3>{\inputminted[fontsize=\small]{python}{code/paradigms/oop/class_abstract.py}}
	\end{columns}
\end{frame}

\begin{frame}{Class methods, class variables}
	\begin{itemize}
		\item class methods only have access to class variables and other class methods
		\item important use case: to provide other constructors
	\end{itemize}
\end{frame}

\begin{frame}{Class diagrams}
	
\end{frame}

\begin{frame}{Strenghts and Weaknesses}
	
\begin{block}{Strengths}
	\begin{itemize}
		\item Easy to read and understand if done well (very natural way of thinking)
		\item Natural way to structure large projects
		\item Very wide spread way of thinking
		\item Especially applicable to problems many very complex data types
	\end{itemize}
\end{block}
\begin{block}{Weaknesses}
\begin{itemize}
	\item Code duplicity due to wrong abstractions
	\item Lasagna code: Too many layers 
	\item Hard to parallelize to mutabilities
\end{itemize}
\end{block}
\end{frame}