\subsection[Functional]{Functional programming}

\frame{\tableofcontents[currentsection, currentsubsection]}

\subsubsection{Definition}

\begin{frame}{Functional programming}
	% https://www.geeksforgeeks.org/functional-programming-paradigm/
	% https://en.wikipedia.org/wiki/Functional_programming#Pure_functions
	Functional programming
	\begin{itemize}
		\item expresses its computations in the style of mathematical functions
		\item emphasizes 
		\begin{itemize}
			\item \hhl{expressions} \srem{(\enquote{is} something: a series of identifiers, literals and operators that reduces to a value)} 
			\item[over\hspace{-0.7em}]
			\item \hhl{statements} \srem{(\enquote{does} something, e.g. stores value, etc.)}
		\end{itemize} 
		$\lra$ \hhl{declarative} nature
		\item Avoids \hhl{mutability} \srem{(instead of changing properties, I need to create copies with the changed property)}
		\item Avoids \hhl{side effects} \srem{(expressions should not change or depend on any external state)}  
	\end{itemize}
	
\end{frame}

%\begin{frame}[t]{Referential transparency}
%	\only<+->{
%		No side effects implies referential transparency:
%	
%		\medskip
%		\begin{center}
%		An expression is \hhl{referential transparent} if it can be replaced with its value without changing the outcome of the program.
%		\end{center}
%	}
%
%	Which of the following functions are referential transparent?
%%	\only<+->{
%%		\bigskip
%%		In particular for functions: \hhl{$x = y$ $\Lra$ $f(x) = f(y)$}.
%%	}
%	\only<+>{
%		\inputminted[]{python}{code/paradigms/fp/referential_transparency.py}
%	}
%\end{frame}

\begin{frame}[t]{Pure functions}
	% https://en.wikipedia.org/wiki/Pure_function
	\only<+->{
		A function is called pure if
		\begin{enumerate}
			\item Same arguments $\Lra$ same return value \srem{($x=y\ \Lra\ f(x)=f(y)$)}
			\item The evaluation has no side effects \srem{(no change in non-local variables, ...)}
		\end{enumerate}
	}
	
	\bigskip
	\only<2->{Which of the following functions are pure?}
	%
	\begin{columns}[t]
		\column{0.5\textwidth}
		\only<2->{
			\inputminted[lastline=15]{python}{code/paradigms/fp/referential_transparency.py}
		}
		\column{0.5\textwidth}
		\only<2->{
			\inputminted[firstline=18]{python}{code/paradigms/fp/referential_transparency.py}
		}
		\only<3->{
			\bigskip
			\stress{Answer}: \texttt{f1} is pure; \texttt{f1}, \texttt{f3}, \texttt{f5} violate rule 2; \texttt{f4} violates rule 1.
		}
	\end{columns}
	
\end{frame}

\begin{frame}[t]{Non strict evaluation}{}
	\begin{itemize}
		\item Some functional programming languages use \hldefn{non-strict evaluation}: The arguments of a function are \emph{only} evaluated once the function is called.
		
		\only<2->{
			\medskip
			Example: \mintinline{python}{print(sqrt(sin(a**2)))}
			
			\medskip
			In a \hhl{strict} language \srem{(e.g. python, C++)}, we evaluate inside out: 
			%
			\begin{equation*}
				a\lmt a^2\lmt \sin{a^2} \lmt \sqrt{\sin{a^2}}
			\end{equation*}
			%
			In a \hhl{non-strict} language, the evaluation of the inner part is \stress{deferred}, until it is actually needed. 
		}
		\item<3->
		\medskip
		But python actually has something similar in the concept of \hhl{\texttt{generators}}:
		\inputminted[]{python}{code/paradigms/fp/generators.py}
	
		%
		\item<4-> This allows for \hhl{infinite data structures} \srem{(which can be more practical than they sounds)}
	\end{itemize}
\end{frame}

\begin{frame}[t]{Memoization}
	\begin{itemize}
		\item<+-> Non strict evaluation together with \hldefn{sharing} (avoid repeated evaluation of the same expression) is called \hldefn{lazy evaluation}
		%
		\item<+-> Generally, functional programming can get cheap performance boosts by very simple \hldefn{memoization}: Storing the results of expensive \stress{pure} function calls in a cache
		
		%\medskip
		\only<+->{\inputminted[]{python}{code/paradigms/fp/memoization.py}}
	\end{itemize}
\end{frame}

\begin{frame}{Higher order functions}
	A \hldefn{higher order function} does one of the following:
	\begin{itemize}
		\item returns a function
		\item takes a function as an argument
	\end{itemize}
	Opposite: \hldefn{first-order function}.
	
	\medskip 
	\srem{Mathematical examples (usually called \defn{operators} or \defn{functionals}): differential operator, integration, \dots}
	
	\medskip
	Higher level functions are the FP answer to template methods in OOP \srem{(\enquote{configuring} object behavior by overriding methods in subclasses)}.
	
	\medskip
	{We have already met two higher order functions from the python \texttt{functools} library: \texttt{map} and \texttt{reduce}, each taking a function and an iterator as arguments.}
	\inputminted[lastline=8]{python}{code/paradigms/fp/higher_order.py}
\end{frame}

\begin{frame}{Higher order functions II}
	A function that also returns a function:
	
	\inputminted[lastline=8]{python}{code/paradigms/fp/higher_order_2.py}
\end{frame}

\begin{frame}{Type systems and multiple dispatch}
	$\lra$ compare with inheritance
\end{frame}

\begin{frame}{Referential transparency}
	% https://stackoverflow.com/questions/210835/what-is-referential-transparency
\end{frame}

\begin{frame}{Monads}
	
\end{frame}

\begin{frame}[t]{Example: Loops}
	\only<1->{Let's consider a function that calculates $\sum_{i=0}^N i^2$:}
	%
	\only<+->{\inputminted[]{python}{code/paradigms/fp/sum_loop.py}}
	
	
	\only<+->{
		\bigskip
		This is a function, but does not follow the FP paradigm:
		\begin{itemize}
			\item More statements \srem{(assignments, loops, \dots)} than expressions
			\item The for loop segment is not free of side effects \srem{(value of \texttt{result} changes)}
			\item Repeated reassignments of \texttt{result} are frowned upon \srem{(or impossible)}
		\end{itemize}
	}
	\only<+->{
	\bigskip
		How to change this? $\lra$ Use \hhl{recursion}
		%
		\inputminted[]{python}{code/paradigms/fp/sum_head_recursion.py}
	}
	%Tail recursions $\lra$ Compiler optimization
\end{frame}

\begin{frame}[t]{Example: Loops II}
	\only<1->{
		The previous example is called a \hhl{head recursion} \srem{(recursion before computation)}; using a \hhl{tail recursion} \srem{(recursion after computation)} is preferable due to better compiler optimization:
	}
	%
	\only<+->{
		\inputminted[]{python}{code/paradigms/fp/sum_tail_recursion.py}
	}
	\only<+->{
		\bigskip
		Another FP way is to use the higher level functions \hhl{\texttt{map}} and \hhl{\texttt{reduce}} together with anonymous functions (\hhl{lambda}):
		\inputminted[]{python}{code/paradigms/fp/sum_map_reduce.py}
	}
\end{frame}

\begin{frame}{Loops III}
	$\lra$ Write about how the map-reduce pattern is quite a big topic in HPC
\end{frame}

\subsubsection{Signature moves}

\subsubsection{Strenghts and Weaknesses}

\begin{frame}{Strenghts and Weaknesses}
\begin{block}{Strengths}
	\begin{itemize}
		\item Proving things mathematically
		\item Testing things
		\item Very short and concise notations of algorithms
		\item Sophisticated abstractions of logic $\lra$ very high code reuse
		\item Performance boost because of easy parallelization
	\end{itemize}
\end{block}

\begin{block}{Weaknesses}
	\begin{itemize}
		\item Less \enquote{natural} way to approach problems (\enquote{objects} are a natural way of thinking to most people)
		\item Steeper learning curve
		\item Can be harder to read (higher level functions, recursions, ...)
		\item Performance issues due to immutability
		\item Long tradition in academia, but gaining traction in other fields
	\end{itemize}
\end{block}

\end{frame}